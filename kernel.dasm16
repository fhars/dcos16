; Copyright (c) 2012 Florian Hars
;
; Permission is hereby granted, free of charge, to any person obtaining
; a copy of this software and associated documentation files (the
; "Software"), to deal in the Software without restriction, including
; without limitation the rights to use, copy, modify, merge, publish,
; distribute, sublicense, and/or sell copies of the Software, and to
; permit persons to whom the Software is furnished to do so, subject to
; the following conditions:
;
; The above copyright notice and this permission notice shall be
; included in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

         SET A, 0
:_pc_initloop
         SET [_pc_status + A], 0
         ADD A, 1
         IFG 16, A
         SET PC, _pc_initloop
         SET [_pc_curr_proc], 15
         ;start the first process
         SET A, init
         SET B, 0
         JSR fork
         JSR yield

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  SCHEDULER CORE
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; fork starts a new process (up to a limit of 16 processes total)
;
; input A: the start address of the new process
; input B: the run mode
;           0: daemon mode, the new process is independent from
;              the calling process
;           1: child mode, the calling process can query the
;              return value of the child one it has exited
;           2: sync mode, the parent waits for the child to
;              terminate
; return A:
;     0 on a successful daemon fork
;     child PID on a successful child fork
;     return value after a sync child has finished
;     -1 if no free slot remains
; return B:
;     0 on a successful fork
;     -1 if no free slot remains (to distingush an error
;        from a sync return of -1)
:fork
         SET [_pc_tmp_PC], A
         SET [_pc_tmp_B], B
         SET [_pc_tmp_SP], SP
         SET SP, 0xF000
         SET C, [_pc_curr_proc]
         SET B, C
:_pc_next_free
         ADD B, 1
         AND B, 0xF
         IFE B, C
         SET PC, _pc_fork_error
         SET A, [_pc_status + B]
         AND A, 0x8000
         IFE A, 0x8000
         SET PC, _pc_next_free

         ; now B contains the number of the next free slot

         ; store the PPID in _pc_tmp_C
         SET [_pc_tmp_C], C

         ; mark the process slot as running and initialize
         ; the register file
         SET [_pc_status + B], 0xC000
         SET A, B
         MUL A, 10

         ; next instruction is the value passed in
         SET [_pc_save_PC + A], [_pc_tmp_PC]

         ; SP points one over the top of the allocated page
         SET C, B
         ADD C, 1
         MUL C, 0x100
         ADD C, 0xEFFF
         SET [C], exit
         SET [_pc_save_SP + A], C

         ; registers XYZIJ are shared with the caller
         SET [_pc_save_A + A], 0
         SET [_pc_save_B + A], 0
         SET [_pc_save_C + A], 0
         JSR _pc_save_xyzij

         ;  clear the status cell
         SET PUSH, B
         SET A, 0
         JSR _pc_i2hex_cell

         SET A, PEEK
         SET C, 0x07
         JSR _pc_set_cell_color

         SET B, POP
         ; finally chek the run mode
         SET A, [_pc_tmp_B]

         SET SP, [_pc_tmp_SP]
         ; mode is daemon, do not remember PPID, A is 0
         IFN A, 0
         ADD PC, 2
         SET B, 0
         SET PC, POP

         set C, [_pc_tmp_C]

         ; remember the PPID
         BOR [_pc_status + B], C
         BOR [_pc_status + B], 0x10

         ; if the call is asynchronous, set A to the PID
         ; and return
         IFN A, 1
         ADD PC, 3
         SET A, B
         SET B, 0
         SET PC, POP

         ; else, set the sync bit and put the caller to sleep
         SET A, C
:_pc_sleep_waiting
         BOR [_pc_status + B], 0x20
         AND [_pc_status + A], 0xBFFF
         BOR [_pc_status + A], 0x1000
         SET PC, yield

:_pc_fork_error
         SET A, -1
         SET B, -1
         SET PC, POP

; wait for the result of a child process
;
; input A: the PID of the process to wait for
; input B: wait mode, 0: blocking, 1: non-blocking
; output A / B:
;   -1 / -1 : PID is not a child of this process
;   0  / -1 : child has not finished (non-blocking)
;  res /  0 : child has finished
:wait
        IFB A, 0xFFF0
        SET PC, _pc_fork_error
        SET [_pc_tmp_A], A
        SET [_pc_tmp_B], B
        SET A, [_pc_status + A]
        SET B, A
        AND A, 0xF
        IFN A, [_pc_curr_proc]
        SET PC, _pc_fork_error

        SET A, [_pc_tmp_A]

        IFB B, 0x2000
        SET PC, _pc_waitexited

        IFE [_pc_tmp_B], 0
        SET PC, _pc_waitblocked

        ; waiting non-blocking on a runnig process
        SET A, 0
        SET B, -1
        SET PC, POP

; if we want a blocking wait on a runnig process,
; treat is as if it had been a sync fork
:_pc_waitblocked
        SET B, A
        SET A, [_pc_curr_proc]
        SET PC, _pc_sleep_waiting

:_pc_waitexited
        SET [_pc_status + A], 0
        SET PUSH, A
        SET C, 0
        JSR _pc_set_cell_color
        SET A, POP
        MUL A, 10
        SET A, [_pc_save_A + A]
        SET B, 0
        SET PC, POP

; exit terminates a running process, optionally remembering
; the value of the A register for the parent process.
;
;
; The routine can safely ignore SP (alternatively, it
; doesn't matter if it is called with JSR exit or SET PC, exit),
; since it doesn't return and this processes stack is discarded.
;
; input A : the value to return to the parent proces
:exit
         SET X, A
         SET A, [_pc_curr_proc]
         SET C, [_pc_status + A]

         ; A daemon process just terminates
         IFB C, 0x10
         SET PC, _pc_exit_child
         SET [_pc_status + A], 0
         SET C, 0x00
         JSR _pc_set_cell_color
         SET A, [_pc_curr_proc]
         SET PC, _pc_next_proc

:_pc_exit_child
         AND C, 0xF
         IFB [_pc_status + C], 0x1000 ; parent sleeps waiting
         SET PC, _pc_exit_sync

         ; mark the process a zombie and remember A
         AND [_pc_status + A], 0xBFFF
         BOR [_pc_status + A], 0x2000
         MUL A, 10
         SET [_pc_save_A + A], X
         SET PC, _pc_next_proc

:_pc_exit_sync
         ; mark slot as free
         SET [_pc_status + A], 0
         ; mark parent as running
         AND [_pc_status + C], 0xEFFF
         BOR [_pc_status + C], 0x4000
         ; set return value for parent
         MUL C, 10
         SET [_pc_save_A + C], X
         SET [_pc_save_B + C], 0
         SET C, 0x00
         JSR _pc_set_cell_color
         SET A, [_pc_curr_proc]
         SET PC, _pc_next_proc

:yield
         SET [_pc_tmp_A], A
         SET A, [_pc_curr_proc]
         ; save register values of the yielding process
         MUL A, 10
         SET [_pc_save_A + A], [_pc_tmp_A]
         SET [_pc_save_B + A], B
         SET [_pc_save_C + A], C
         SET [_pc_save_PC + A], POP
         SET [_pc_save_SP + A], SP

         SET SP, 0xF000
         JSR _pc_save_xyzij

         SET A, [_pc_tmp_A]
         SET B, [_pc_curr_proc]
         JSR _pc_i2hex_cell

         ; seach for the next running process
         SET A, [_pc_curr_proc]
:_pc_next_proc
         ADD A, 1
         AND A, 0xF
         SET B, [_pc_status + A]
         AND B, 0xC000
         IFN B, 0xC000
         SET PC, _pc_next_proc

:_pc_run_next_proc
         SET [_pc_curr_proc], A
         MUL A, 10

         ; restore register values of the next process
         SET [_pc_tmp_A], [_pc_save_A + A]
         SET B, [_pc_save_B + A]
         SET C, [_pc_save_C + A]
         SET X, [_pc_save_X + A]
         SET Y, [_pc_save_Y + A]
         SET Z, [_pc_save_Z + A]
         SET I, [_pc_save_I + A]
         SET J, [_pc_save_J + A]
         SET [_pc_tmp_PC], [_pc_save_PC + A]
         SET SP, [_pc_save_SP + A]

         SET A, [_pc_tmp_A]
         SET PC, [_pc_tmp_PC]

:_pc_save_xyzij
         SET [_pc_save_X + A], X
         SET [_pc_save_Y + A], Y
         SET [_pc_save_Z + A], Z
         SET [_pc_save_I + A], I
         SET [_pc_save_J + A], J
         set PC, POP

; persistend state of the scheduler
:_pc_curr_proc DATA 15

; temporary storage of the scheduler
:_pc_tmp_A   DATA 0
:_pc_tmp_B   DATA 0
:_pc_tmp_C   DATA 0
:_pc_tmp_PC  DATA 0
:_pc_tmp_SP  DATA 0
; Persistent register files of the processes

; A status word for each process
;
;  Bit
;  0 - 3  PID of the parent process if not a daemon process
;  4      1 if this is a child process
;  5      1 if this is a sync child
;
;  12     1 if this process is waiting for a child
;  13     1 if this a a zombie process, 0 if waiting
;  14     1 if this process is running, 0 if waiting
;  15     1 if this slot is used, 0 if free
;
:_pc_status  RESERVE 16

; A register file for each of the processes
:_pc_save_A  DATA 0
:_pc_save_B  DATA 0
:_pc_save_C  DATA 0
:_pc_save_X  DATA 0
:_pc_save_Y  DATA 0
:_pc_save_Z  DATA 0
:_pc_save_I  DATA 0
:_pc_save_J  DATA 0
:_pc_save_PC DATA 0
:_pc_save_SP DATA 0
         RESERVE 150

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  DISPLAY FUNCTIONS
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; set the colors for this processes status cell
;
; input A: the foreground and background colors (0 to 7) in the
; lowest two nibbles of register A
; clobbers: A, B, C
:status_color
        SET C, A
        SET A, [_pc_curr_proc]
        SET PC, _pc_set_cell_color


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Internal display logic

; Temporary storage for display helper functions
:_pc_dtm_A  DATA 0
:_pc_dtm_C  DATA 0
:_pc_dtm_X  DATA 0

; print the hex representaion of the number in A in the
; cell for the slot number in B

:_pc_i2hex_cell
        AND B, 0xF
        MUL B, 4
        ADD B, 0x8000

; convert the value in register A into a hex string stored at the
; address pointed to by register B
;
; The function leaves the color information intact
:_pc_i2hex
        SET [_pc_dtm_A], A
        SET [_pc_dtm_X], X
        SET [_pc_dtm_C], C
        SET C, 16
:_pc_i2hexl SET A, [_pc_dtm_A]
        SUB C, 4
        SHR A, C
        AND A, 0xF
        IFG A, 9
        ADD A, 0x7
        ADD A, 0x30
        SET X, [B]
        AND X, 0xFF00
        BOR X, A
        SET [B], X
        ADD B, 1
        IFN C, 0
        SET PC, _pc_i2hexl
        SET X, [_pc_dtm_X]
        SET C, [_pc_dtm_C]
        SET PC, POP

; set color for a processes status cell
;
; input A: the process slot number
; input C: the color

:_pc_set_cell_color
        AND A, 0xF
        MUL A, 4
        ADD A, 0x8000
        SET B, 4

; set the color for an array of screen cells
;
; input A: the address of the start cells
; input B: the number of cells
; input C: the color (in the lower 8 bits), highlight bits are ignored

:_pc_set_color
        SET [_pc_dtm_A], X
        AND C, 0x77
        SHL C, 8
:_pc_set_color_l
        SET X, [A]
        AND X, 0x88FF ; keep characters and highlight bits
        BOR X, C
        SET [A], X
        SUB B, 1
        ADD A, 1
        IFN B, 0
        SET PC, _pc_set_color_l
        SET X, [_pc_dtm_A]
        SET PC, POP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  EXAMPLE AND DEBUG CODE
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:foo    DATA 0xFFFF
:db     DATA 0
:foo2   DATA 0xFFFF
:pid    DATA 0
:pid2   DATA 0
:init   SET X, 1
        SET A, 0x06
        JSR status_color
:loop1 set Y, 0
       SET A, count4
       SET B, 1
       JSR fork
       SET [pid], A
       SET Z, A

:loop2 SET A, [pid]
       ADD [db], 1
       SET B, 1
       ADD Y, 1
       ADD [db], 0x10
       JSR yield
       ADD [db], 0x10
       JSR wait
       IFN B,0
       SET PC, loop2
       ADD X, 1
       ADD [db], 0x100
       IFG 4, X
       SET PC, loop1


       SET [CC], 0
       SET X, 0
       SET Y, 0
       SET A, count4
       SET B, 2
       JSR fork
       SET X,1

       SET [db], 0xC000

       SET A, fact
       SET B, 1
       SET X, 6
       JSR fork
       SET [pid], A
       SET A, fact_col
       SET Z, A
       SET B, 1
       SET X, 8
       JSR fork
       SET [pid2], A

:loop3 SET A, [pid]
       SET B, 1
       ADD Y, 1
       JSR yield
       JSR wait
       IFN B,0
       SET PC, loop3

       SET Y, 0
:loop4 JSR yield
       SET A, [pid2]
       SET B, 1
       ADD Y, 1
       JSR wait
       IFN B,0
       SET PC, loop4

:crash SET PC, crash

:count4 SET I, 0
:loopc  SET A, I
        JSR yield
        ADD I, 1
        ADD [CC], 1
        SET J, [CC]
        IFG I, 3
        SET PC, POP
        SET PC, loopc

:fact_col
        SET A, 0x34
        JSR status_color
:fact
        SET A, X
        JSR fact_rec
        SET PC, POP
:fact_rec
        JSR yield
        IFE A, 1
        SET PC, POP
        SET PUSH, A
        SUB A, 1
        JSR fact_rec
        MUL A, POP
        JSR yield
        SET PC, POP
:cc DATA 0
