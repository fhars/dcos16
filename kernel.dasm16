; Copyright (c) 2012 Florian Hars
;
; Permission is hereby granted, free of charge, to any person obtaining
; a copy of this software and associated documentation files (the
; "Software"), to deal in the Software without restriction, including
; without limitation the rights to use, copy, modify, merge, publish,
; distribute, sublicense, and/or sell copies of the Software, and to
; permit persons to whom the Software is furnished to do so, subject to
; the following conditions:
;
; The above copyright notice and this permission notice shall be
; included in all copies or substantial portions of the Software.
;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

         SET A, 0
:initloop
         SET [status + A], 0
         ADD A, 1
         IFG 16, A
         SET PC, initloop
         SET [curr_proc], 15
         ;start the first process
         SET A, init
         SET B, 0
         JSR fork
         JSR yield

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  SCHEDULER CORE
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; fork starts a new process (up to a limit of 16 processes total)
;
; input A: the start address of the new process
; input B: the run mode
;           0: daemon mode, the new process is independent from
;              the calling process
;           1: child mode, the calling process can query the
;              return value of the child one it has exited
;           2: sync mode, the parent waits for the child to
;              terminate
; return A:
;     0 on a successful daemon fork
;     child PID on a successful child fork
;     return value after a sync child has finished
;     -1 if no free slot remains
; return B:
;     0 on a successful fork
;     -1 if no free slot remains (to distingush an error
;        from a sync return of -1)
:fork
         SET [tmp_PC], A
         SET [tmp_B], B
         SET [tmp_SP], SP
         SET SP, 0xF000
         SET C, [curr_proc]
         SET B, C
:next_free
         ADD B, 1
         AND B, 0xF
         IFE B, C
         SET PC, fork_error
         SET A, [status + B]
         AND A, 0x8000
         IFE A, 0x8000
         SET PC, next_free

         ; now B contains the number of the next free slot

         ; store the PPID in tmp_C
         SET [tmp_C], C

         ; mark the process slot as running and initialize
         ; the register file
         SET [status + B], 0xC000
         SET A, B
         MUL A, 10

         ; next instruction is the value passed in
         SET [save_PC + A], [tmp_PC]

         ; SP points one over the top of the allocated page
         SET C, B
         ADD C, 1
         MUL C, 0x100
         ADD C, 0xF000
         SET [save_SP + A], C

         ; registers XYZIJ are shared with the caller
         SET [save_A + A], 0
         SET [save_B + A], 0
         SET [save_C + A], 0
         JSR save_xyzij

         ;  clear the status cell
         SET PUSH, B
         SET A, 0
         JSR i2hex_cell

         SET A, PEEK
         SET C, 0x07
         JSR set_cell_color

         SET B, POP
         ; finally chek the run mode
         SET A, [tmp_B]

         SET SP, [tmp_SP]
         ; mode is daemon, do not remember PPID, A is 0
         IFN A, 0
         ADD PC, 2
         SET B, 0
         SET PC, POP

         set C, [tmp_C]

         ; remember the PPID
         BOR [status + B], C
         BOR [status + B], 0x10

         ; if the call is asynchronous, set A to the PID
         ; and return
         IFN A, 1
         ADD PC, 3
         SET A, B
         SET B, 0
         SET PC, POP

         ; else, set the sync bit and put the caller to sleep
         BOR [status + B], 0x20
         AND [status + C], 0xBFFF
         SET PC, yield

:fork_error
         SET A, -1
         SET B, -1
         SET PC, POP

; wait for the result of a child process
;
; input A: the PID of the process to wait for
; input B: wait mode, 0: blocking, 1: non-blocking
; output A / B:
;   -1 / -1 : PID is not a child of this process
;   0  / -1 : child has not finished (non-blocking)
;  res /  0 : child has finished
:wait
        IFB A, 0xFFF0
        SET PC, fork_error
        SET [tmp_A], A
        SET [tmp_B], B
        SET A, [status + A]
        SET B, A
        AND A, 0xF
        IFN A, [curr_proc]
        SET PC, fork_error

        SET A, [tmp_A]

        IFB B, 0x2000
        SET PC, wait_exited

        IFE [tmp_B], 0
        SET PC, wait_blocked

        ; waiting non-blocking on a runnig process
        SET A, 0
        SET B, -1
        SET PC, POP

; if we want a blocking wait on a runnig process,
; treat is as if it had been a sync fork
:wait_blocked
        BOR [status + A], 0x20
        SET A, [curr_proc]
        AND [status + A], 0xBFFF
        SET PC, yield

:wait_exited
        SET [status + A], 0
        SET PUSH, A
        SET C, 0
        JSR set_cell_color
        SET A, POP
        MUL A, 10
        SET A, [save_A + A]
        SET B, 0
        SET PC, POP

; exit terminates a running process, optionally remembering
; the value of the A register for the parent process.
;
;
; The routine can safely ignore SP (alternatively, it
; doesn't matter if it is called with JSR exit or SET PC, exit),
; since it doesn't return and this processes stack is discarded.
;
; input A : the value to return to the parent proces
:exit
         SET X, A
         SET A, [curr_proc]
         SET C, [status + A]

         ; A daemon process just terminates
         IFB C, 0x10
         SET PC, exit_child
         SET [status + A], 0
         SET C, 0x00
         JSR set_cell_color
         SET A, [curr_proc]
         SET PC, next_proc

:exit_child
         AND C, 0xF
         IFB [status + A], 0x20
         SET PC, exit_sync

         ; mark the process a zombie and remember A
         AND [status + A], 0xBFFF
         BOR [status + A], 0x2000
         MUL A, 10
         SET [save_A + A], X
         SET PC, next_proc

:exit_sync
         ; mark slot as free
         SET [status + A], 0
         ; mark parent as running
         BOR [status + C], 0x4000
         ; set return value for parent
         MUL C, 10
         SET [save_A + C], X
         SET [save_B + C], 0
         SET C, 0x00
         JSR set_cell_color
         SET A, [curr_proc]
         SET PC, next_proc

:yield
         SET [tmp_A], A
         SET A, [curr_proc]
         ; save register values of the yielding process
         MUL A, 10
         SET [save_A + A], [tmp_A]
         SET [save_B + A], B
         SET [save_C + A], C
         SET [save_PC + A], POP
         SET [save_SP + A], SP

         SET SP, 0xF000
         JSR save_xyzij

         SET A, [tmp_A]
         SET B, [curr_proc]
         JSR i2hex_cell

         ; seach for the next running process
         SET A, [curr_proc]
:next_proc
         ADD A, 1
         AND A, 0xF
         SET B, [status + A]
         AND B, 0xC000
         IFN B, 0xC000
         SET PC, next_proc

:run_next_proc
         SET [curr_proc], A
         MUL A, 10

         ; restore register values of the next process
         SET [tmp_A], [save_A + A]
         SET B, [save_B + A]
         SET C, [save_C + A]
         SET X, [save_X + A]
         SET Y, [save_Y + A]
         SET Z, [save_Z + A]
         SET I, [save_I + A]
         SET J, [save_J + A]
         SET [tmp_PC], [save_PC + A]
         SET SP, [save_SP + A]

         SET A, [tmp_A]
         SET PC, [tmp_PC]

:save_xyzij
         SET [save_X + A], X
         SET [save_Y + A], Y
         SET [save_Z + A], Z
         SET [save_I + A], I
         SET [save_J + A], J
         set PC, POP

; persistend state of the scheduler
:curr_proc DATA 15

; temporary storage of the scheduler
:tmp_A   DATA 0
:tmp_B   DATA 0
:tmp_C   DATA 0
:tmp_PC  DATA 0
:tmp_SP  DATA 0
; Persistent register files of the processes

; A status word for each process
;
;  Bit
;  0 - 3  PID of the parent process if not a daemon process
;  4      1 if this is a child process
;  5      1 if this is a sync child
;
;  13     1 if this a a zombie process, 0 if waiting
;  14     1 if this process is running, 0 if waiting
;  15     1 if this slot is used, 0 if free
;
:status  RESERVE 16

; A register file for each of the processes
:save_A  DATA 0
:save_B  DATA 0
:save_C  DATA 0
:save_X  DATA 0
:save_Y  DATA 0
:save_Z  DATA 0
:save_I  DATA 0
:save_J  DATA 0
:save_PC DATA 0
:save_SP DATA 0
         RESERVE 150

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  DISPLAY FUNCTIONS
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; set the colors for this processes status cell
;
; input A: the foreground and background colors (0 to 7) in the
; lowest two nibbles of register A
; clobbers: A, B, C
:status_color
        SET C, A
        SET A, [curr_proc]
        SET PC, set_cell_color


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Internal display logic

; Temporary storage for display helper functions
:dtm_A  DATA 0
:dtm_C  DATA 0
:dtm_X  DATA 0

; print the hex representaion of the number in A in the
; cell for the slot number in B

:i2hex_cell
        AND B, 0xF
        MUL B, 4
        ADD B, 0x8000

; convert the value in register A into a hex string stored at the
; address pointed to by register B
;
; The function leaves the color information intact
:i2hex
        SET [dtm_A], A
        SET [dtm_X], X
        SET [dtm_C], C
        SET C, 16
:i2hexl SET A, [dtm_A]
        SUB C, 4
        SHR A, C
        AND A, 0xF
        IFG A, 9
        ADD A, 0x7
        ADD A, 0x30
        SET X, [B]
        AND X, 0xFF00
        BOR X, A
        SET [B], X
        ADD B, 1
        IFN C, 0
        SET PC, i2hexl
        SET X, [dtm_X]
        SET C, [dtm_C]
        SET PC, POP

; set color for a processes status cell
;
; input A: the process slot number
; input C: the color

:set_cell_color
        AND A, 0xF
        MUL A, 4
        ADD A, 0x8000
        SET B, 4

; set the color for an array of screen cells
;
; input A: the address of the start cells
; input B: the number of cells
; input C: the color (in the lower 8 bits), highlight bits are ignored

:set_color
        SET [dtm_A], X
        AND C, 0x77
        SHL C, 8
:set_color_l
        SET X, [A]
        AND X, 0x88FF ; keep characters and highlight bits
        BOR X, C
        SET [A], X
        SUB B, 1
        ADD A, 1
        IFN B, 0
        SET PC, set_color_l
        SET X, [dtm_A]
        SET PC, POP

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  EXAMPLE AND DEBUG CODE
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

:foo    DATA 0xFFFF
:db     DATA 0
:foo2   DATA 0xFFFF
:pid    DATA 0
:pid2   DATA 0
:init   SET X, 1
        SET A, 0x06
        JSR status_color
:loop1 set Y, 0
       SET A, count4
       SET B, 1
       JSR fork
       SET [pid], A
       SET Z, A

:loop2 SET A, [pid]
       ADD [db], 1
       SET B, 1
       ADD Y, 1
       ADD [db], 0x10
       JSR yield
       ADD [db], 0x10
       JSR wait
       IFN B,0
       SET PC, loop2
       ADD X, 1
       ADD [db], 0x100
       IFG 4, X
       SET PC, loop1


       SET [CC], 0
       SET X, 0
       SET Y, 0
       SET A, count4
       SET B, 2
       JSR fork
       SET X,1

       SET [db], 0xC000

       SET A, fact
       SET B, 1
       SET X, 6
       JSR fork
       SET [pid], A
       SET A, fact_col
       SET Z, A
       SET B, 1
       SET X, 8
       JSR fork
       SET [pid2], A

:loop3 SET A, [pid]
       SET B, 1
       ADD Y, 1
       JSR yield
       JSR wait
       IFN B,0
       SET PC, loop3

       SET Y, 0
:loop4 JSR yield
       SET A, [pid2]
       SET B, 1
       ADD Y, 1
       JSR wait
       IFN B,0
       SET PC, loop4

:crash SET PC, crash

:count4 SET I, 0
:loopc  SET A, I
        JSR yield
        ADD I, 1
        ADD [CC], 1
        SET J, [CC]
        IFG I, 3
        JSR exit
        SET PC, loopc

:fact_col
        SET A, 0x34
        JSR status_color
:fact
        SET A, X
        JSR fact_rec
        SET PC, exit
:fact_rec
        JSR yield
        IFE A, 1
        SET PC, POP
        SET PUSH, A
        SUB A, 1
        JSR fact_rec
        MUL A, POP
        JSR yield
        SET PC, POP
:cc DATA 0
