         SET A, 0
:initloop
         SET [status + A], 0
         ADD A, 1
         IFG 176, A
         SET PC, initloop
         ;start the first process
         SET A, init
         SET B, 0
         JSR fork
         JSR yield

; fork starts a new process (up to a limit of 16 processes total)
;
; input A: the start address of the new process
; input B: the run mode
;           0: daemon mode, the new process is independent from
;              the calling process
;           1: child mode, the calling process can query the
;              return value of the child one it has exited
;           2: sync mode, the parent waits for the child to
;              terminate
; return A:
;     0 on a successful daemon fork
;     child PID on a successful child fork
;     return value after a sync child has finished
;     -1 if no free slot remains
; return B:
;     0 on a successful fork
;     -1 if no free slot remains (to distingush an error
;        from a sync return of -1)
:fork
         SET [tmp_PC], A
         SET [tmp_B], B
         SET C, [curr_proc]
         SET B, C
:next_free
         ADD B, 1
         AND B, 0xF
         IFE B, C
         SET PC, fork_error
         SET A, [status + B]
         AND A, 0x8000
         IFE A, 0x8000
         SET PC, next_free

         ; now B contains the number of the next free slot

         ; store the PPID in tmp_C
         SET [tmp_C], C

         ; mark the process slot as running and initialize
         ; the register file
         SET [status + B], 0xC000
         SET A, B
         MUL A, 10

         ; next instruction is the value passed in
         SET [save_PC + A], [tmp_PC]

         ; SP points one over the top of the allocated page
         SET C, B
         ADD C, 1
         MUL C, 0x100
         ADD C, 0xF000
         SET [save_SP + A], C

         ; registers XYZIJ are shared with the caller
         SET [save_A + A], 0
         SET [save_B + A], 0
         SET [save_C + A], 0
         ; here we are wasting a stack frame of the calling process,
         ; Workarounds are about a much code as inlining the JSR,
         ; TODO: decide what is best
         JSR save_xyzij

         ; finally chek the run mode
         SET A, [tmp_B]

         ; mode is daemon, do not remember PPID, A is 0
         IFN A, 0
         ADD PC, 2
         SET B, 0
         SET PC, POP

         set C, [tmp_C]

         ; remember the PPID
         BOR [status + B], C

         ; if the call is asynchronous, set A to the PID
         ; and return
         IFN A, 1
         ADD PC, 3
         SET A, B
         SET B, 0
         SET PC, POP

         ; else, set the sync bit and put the caller to sleep
         BOR [status + B], 0x10
         AND [status + C], 0xBFFF
         SET PC, POP

:fork_error
         SET A, -1
         SET B, -1
         SET PC, POP

; exit terminates a running process, optionally remembering
; the value of the A register for the parent process.
;
;
; The routine can safely ignore SP (alternatively, it
; doesn't matter if it is called with JSR exit or SET PC, exit),
; since it doesn't return and this processes stack is discarded.
;
; input A : the value to return to the parent proces
:exit
         SET X, A
         SET A, [curr_proc]
         SET C, [status + A]
         AND C, 0xF

         ; A daemon process just terminates
         IFN C, 0
         SET PC, exit_child
         SET [status + A], 0
         SET PC, next_proc

:exit_child
         IFB [status + A], 0x10
         SET PC, exit_sync

         ; mark the process a zombie and remember A
         AND [status + A], 0xBFFF
         BOR [status + A], 0x2000
         SET [save_A + A], X
         SET PC, next_proc

:exit_sync
         ; mark slot as free
         SET [status + A], 0
         ; mark parent as running
         BOR [status + C], 0x8000
         ; set return value for parent
         MUL C, 10
         SET [save_A + C], X
         SET [save_B + C], 0
         SET PC, next_proc

:yield
         SET [tmp_A], A
         SET A, [curr_proc]
         ; save register values of the yielding process
         MUL A, 10
         SET [save_A + A], [tmp_A]
         SET [save_B + A], B
         SET [save_C + A], C
         SET [save_PC + A], POP
         SET [save_SP + A], SP

         SET SP, 0xF000
         JSR save_xyzij

         ; seach for the next running process
         SET A, [curr_proc]
:next_proc
         ADD A, 1
         AND A, 0xF
         SET B, [status + A]
         AND B, 0xC000
         IFN B, 0xC000
         SET PC, next_proc

:run_next_proc
         SET [curr_proc], A
         MUL A, 10

         ; restore register values of the next process
         SET [tmp_A], [save_A + A]
         SET B, [save_B + A]
         SET C, [save_C + A]
         SET X, [save_X + A]
         SET Y, [save_Y + A]
         SET Z, [save_Z + A]
         SET I, [save_I + A]
         SET J, [save_J + A]
         SET [tmp_PC], [save_PC + A]
         SET SP, [save_SP + A]

         SET A, [tmp_A]
         SET PC, [tmp_PC]

:save_xyzij
         SET [save_X + A], X
         SET [save_Y + A], Y
         SET [save_Z + A], Z
         SET [save_I + A], I
         SET [save_J + A], J
         set PC, POP

; persistend state of the scheduler
:curr_proc DATA 15

; temporary storage of the scheduler
:tmp_A   DATA 0
:tmp_B   DATA 0
:tmp_C   DATA 0
:tmp_PC  DATA 0

; Persistent register files of the processes

; A status word for each process
;
;  Bit
;  0 - 3  PID of the parent process if not a daemon process
;  4      1 if this is a sync child
;
;  13     1 if this a a zombie process, 0 if waiting
;  14     1 if this process is running, 0 if waiting
;  15     1 if this slot is used, 0 if free
;
:status  RESERVE 16

; A register file for each of the processes
:save_A  DATA 0
:save_B  DATA 0
:save_C  DATA 0
:save_X  DATA 0
:save_Y  DATA 0
:save_Z  DATA 0
:save_I  DATA 0
:save_J  DATA 0
:save_PC DATA 0
:save_SP DATA 0
         RESERVE 150

:init  ADD A, 1
       JSR yield
       IFG A, 100
       JSR exit
       SET PC, init
